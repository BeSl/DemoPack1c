#Использовать cmdline
#Использовать logos
#Использовать tempfiles
#Использовать asserts
#Использовать v8runner
#Использовать strings

Функция Версия() Экспорт

	Версия = "0.1.0";

	Возврат "v" + Версия;

КонецФункции

Процедура ПроверитьНастройкиРепозитарияГит() Экспорт
	Перем КодВозврата;

	КомандаПроверкаСостояния = "git config core.quotepath";
	Лог.Отладка("Выполняю команду "+КомандаПроверкаСостояния);

	Вывод = ПолучитьВыводПроцесса(КомандаПроверкаСостояния, КодВозврата);
	Вывод = СокрЛП(Вывод);
	Лог.Отладка("	Код возврата " + КодВозврата);
	Лог.Отладка("	Вывод команды <" + Вывод + ">");
	Если КодВозврата = 0 И Вывод = "false" Тогда
		Возврат;
	КонецЕсли;

	ВызватьИсключение "У текущего репозитария не заданы необходимые настройки!
	|Выполните команду git config --local core.quotepath false
	|
	|А еще лучше сделать глобальную настройку git config --global core.quotepath false";

КонецПроцедуры

Функция ПолучитьЖурналИзмененийГит()

	Перем КодВозврата;

	Вывод = ВыполнитьКомандуГит("git diff-index --name-status --cached HEAD", КодВозврата, Ложь);
	Если КодВозврата <> 0 Тогда
		Вывод = ВыполнитьКомандуГит("git status --porcelain", КодВозврата, Ложь);

		Если КодВозврата <> 0 Тогда
			ВызватьИсключение "Не удалось собрать журнал изменений git";
		КонецЕсли;

	КонецЕсли;

	Возврат Вывод;

КонецФункции

Функция ВыполнитьКомандуГит(КомандаГит, КодВозврата = Неопределено, ПроверятьНулевойКодВозврата = Истина)

	Лог.Отладка("Запускаю "+КомандаГит);
	Вывод = ПолучитьВыводПроцесса(КомандаГит, КодВозврата);
	Лог.Отладка("	Вывод команды гит: " + Вывод);
	Если ПроверятьНулевойКодВозврата Тогда
		Ожидаем.Что(КодВозврата, "Код возврата `"+КомандаГит+"` должен быть 0, а это не так").Равно(0);
	КонецЕсли;
	Возврат Вывод;
КонецФункции

Функция ПолучитьВыводПроцесса(Знач КоманднаяСтрока, КодВозврата)

	ЛогФайл = ВременныеФайлы.НовоеИмяФайла();
	СтрокаЗапуска = "cmd /C """ + КоманднаяСтрока + " > """ + ЛогФайл + """ 2>&1""";
	Лог.Отладка(СтрокаЗапуска);
	ЗапуститьПриложение(СтрокаЗапуска,, Истина, КодВозврата);
	Лог.Отладка("Код возврата: " + КодВозврата);
	ЧтениеТекста = Новый ЧтениеТекста(ЛогФайл, "utf-8");
	Вывод = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();

	Возврат Вывод;

КонецФункции

Функция ПолучитьИменаИзЖурналаИзмененийГит(Знач ЖурналИзмененийГит) Экспорт
	Лог.Отладка("ЖурналИзмененийГит:");
	МассивИмен = Новый Массив;
	// Если Найти(ЖурналИзмененийГит, Символы.ПС) > 0 Тогда
		МассивСтрокЖурнала = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ЖурналИзмененийГит, Символы.ПС);
	// Иначе
		// ЖурналИзмененийГит = СтрЗаменить(ЖурналИзмененийГит, "A"+Символ(0), "A"+" ");
		// ЖурналИзмененийГит = СтрЗаменить(ЖурналИзмененийГит, "M"+Символ(0), "M"+" ");
		// ЖурналИзмененийГит = СтрЗаменить(ЖурналИзмененийГит, Символ(0), Символы.ПС);
		// МассивСтрокЖурнала = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ЖурналИзмененийГит, Символы.ПС); //Символ(0));
	// КонецЕсли;

	Для Каждого СтрокаЖурнала Из МассивСтрокЖурнала Цикл
		Лог.Отладка("	<%1>", СтрокаЖурнала);
		СтрокаЖурнала = СокрЛ(СтрокаЖурнала);
		СимволИзменений = Лев(СтрокаЖурнала, 1);
		Если СимволИзменений = "A" или СимволИзменений = "M" Тогда
			ИмяФайла = СокрЛП(Сред(СтрокаЖурнала, 2));
			// ИмяФайла = СтрЗаменить(ИмяФайла, Символ(0), "");
			МассивИмен.Добавить(ИмяФайла);
			Лог.Отладка("		В журнале git найдено имя файла <%1>", ИмяФайла);
		КонецЕсли;
	КонецЦикла;
	Возврат МассивИмен;
КонецФункции

Процедура ВывестиСправку()
	Сообщить("Утилита сборки/разборки внешних файлов 1С");
	Сообщить(Версия());
	Сообщить(" ");
	Сообщить("Параметры командной строки:");
	Сообщить("	--decompile inputPath ");
	Сообщить("		Разбор файлов на исходники");

	Сообщить("	--help");
	Сообщить("		Показ этого экрана");

	Сообщить("	--compile inputPath");
	Сообщить("		Собрать файл обработку из исходников");

	//Сообщить("	--git-precommit outputPath [--remove-orig-bin-files]");
	//Сообщить("		Запустить чтение индекса из git и определить список файлов для разбора, разложить их и добавить исходники в индекс");
	//Сообщить("		Если передан флаг --remove-orig-bin-files, обработанные файлы epf/ert будут удалены из индекса git");
	//Сообщить("	--compile inputPath outputPath [--recursive]");
	//Сообщить("		Собрать внешний файл/обработку.");
	//Сообщить("		Если указан параметр --recursive, скрипт будет рекурсивно искать исходные коды отчетов и обработок в указанном каталоге и собирать их, повторяя структуру каталога");
	//Сообщить("	--install");
	//Сообщить("		Установить precommit1c для текущего репозитория git");
КонецПроцедуры


Функция ВозможныеКоманды()

	Если мВозможныеКоманды = Неопределено Тогда
		мВозможныеКоманды = Новый Структура;
		мВозможныеКоманды.Вставить("Декомпилировать", "--decompile");
		мВозможныеКоманды.Вставить("Компилировать", "--compile");

		мВозможныеКоманды.Вставить("Помощь", "--help");
		//мВозможныеКоманды.Вставить("ОбработатьИзмененияИзГит", "--git-precommit");

		//мВозможныеКоманды.Вставить("Установить", "--install");
	КонецЕсли;

	Возврат мВозможныеКоманды;

КонецФункции

Процедура Декомпилировать(ПутьВходящихДанных,ВыходнойКаталог)
КонецПроцедуры
 
Процедура Компилировать(ПутьВходящихДанных,ВыходнойКаталог)
КонецПроцедуры


Функция ЗапускВКоманднойСтроке()
	
	КодВозврата = 0;

	Если ТекущийСценарий().Источник <> СтартовыйСценарий().Источник Тогда
		Возврат Ложь;
	КонецЕсли;

	Лог.Информация("bsl_h" + Версия() + Символы.ПС);

	Попытка

		Парсер = Новый ПарсерАргументовКоманднойСтроки();

		Аргументы = Парсер.РазобратьКоманду(АргументыКоманднойСтроки);
		Лог.Отладка("ТипЗнч(Аргументы)= "+ТипЗнч(Аргументы));

		Если Аргументы = Неопределено Тогда
			ВывестиСправку();
			Возврат Истина;
		КонецЕсли;

		Команда = Аргументы.Команда;
		Лог.Отладка("Передана команда: "+Команда);
		Для Каждого Параметр Из Аргументы.ЗначенияПараметров Цикл
			Лог.Отладка("%1 = %2", Параметр.Ключ, Параметр.Значение);
		КонецЦикла;

		Если Команда = ВозможныеКоманды().Декомпилировать Тогда
			декомпилятор = ЗагрузитьСценарий("tools\Decompile.os");
			декомпилятор.Декомпилировать(Аргументы.ЗначенияПараметров["ПутьВходящихДанных"]);
			//Декомпилировать(Аргументы.ЗначенияПараметров["ПутьВходящихДанных"], Аргументы.ЗначенияПараметров["ВыходнойКаталог"]);
		ИначеЕсли Команда = ВозможныеКоманды().Помощь Тогда
			ВывестиСправку();
		ИначеЕсли Команда = ВозможныеКоманды().ОбработатьИзмененияИзГит Тогда
			ОбработатьИзмененияИзГит(Аргументы.ЗначенияПараметров["ВыходнойКаталог"], Аргументы.ЗначенияПараметров["--remove-orig-bin-files"]);
		ИначеЕсли Команда = ВозможныеКоманды().Компилировать Тогда
			Компилировать(
				Аргументы.ЗначенияПараметров["ПутьВходящихДанных"],
				Аргументы.ЗначенияПараметров["ВыходнойКаталог"],
				Аргументы.ЗначенияПараметров["--recursive"]
			);
		ИначеЕсли Команда = ВозможныеКоманды().Установить Тогда
			УстановитьВКаталог(ТекущийКаталог());
		КонецЕсли;

	Исключение
		Лог.Ошибка(ОписаниеОшибки());
		КодВозврата = 1;
	КонецПопытки;

	Лог.Отладка("Очищаем каталог временной ИБ");
	Попытка
		ВременныеФайлы.Удалить();
	Исключение
	КонецПопытки;

	Возврат Истина;

КонецФункции

Лог = Логирование.ПолучитьЛог("bsl.decompile.log");
Лог.УстановитьУровень(УровниЛога.Отладка);

Если АргументыКоманднойСтроки.Количество() = 0 Тогда
	Лог.Ошибка("Не переданы параметры!");
ИначеЕсли АргументыКоманднойСтроки.Количество() > 1 Тогда
	Лог.Ошибка("Скрипт принимает только один параметр!");
Иначе
	РезультатФ = ЗапускВКоманднойСтроке(АргументыКоманднойСтроки[0]);
КонецЕсли;